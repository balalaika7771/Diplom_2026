\chapter{Листинги кода}

\section{Реализация модуля обнаружения аномалий}

\begin{lstlisting}[language=Java, caption={Модуль обнаружения аномалий на основе LSTM}, label=lst:anomaly_detector, escapeinside={(*@}{@*)}]
package com.autonomous.agents.agents;

import org.springframework.stereotype.Service;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.layers.LSTM;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.RnnOutputLayer;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.lossfunctions.LossFunctions;

import java.util.List;

@Service
public class AnomalyDetectorService {
    private static final int WINDOW_SIZE = 60;
    private MultiLayerNetwork model;
    
    public AnomalyDetectorService() {
        this.model = buildModel();
    }
    
    (*@// Построение модели LSTM для предсказания временных рядов@*)
    private MultiLayerNetwork buildModel() {
        MultiLayerConfiguration conf = new org.deeplearning4j.nn.conf.NeuralNetConfiguration.Builder()
            .seed(123)
            .list()
            .layer(new LSTM.Builder()
                .nIn(1)
                .nOut(50)
                .activation(Activation.TANH)
                .build())
            .layer(new LSTM.Builder()
                .nIn(50)
                .nOut(50)
                .activation(Activation.TANH)
                .build())
            .layer(new DenseLayer.Builder()
                .nIn(50)
                .nOut(25)
                .activation(Activation.RELU)
                .build())
            .layer(new RnnOutputLayer.Builder(LossFunctions.LossFunction.MSE)
                .nIn(25)
                .nOut(1)
                .activation(Activation.IDENTITY)
                .build())
            .build();
        
        MultiLayerNetwork network = new MultiLayerNetwork(conf);
        network.init();
        return network;
    }
    
    (*@// Обучение модели на исторических данных@*)
    public void train(List<Double> data) {
        (*@// Подготовка данных для обучения@*)
        (*@// Реализация подготовки данных и обучения модели@*)
    }
    
    (*@// Обнаружение аномалии в последовательности@*)
    public AnomalyResult detect(List<Double> sequence) {
        (*@// Предсказание следующего значения@*)
        INDArray input = prepareInput(sequence);
        INDArray prediction = model.output(input);
        
        (*@// Вычисление ошибки предсказания@*)
        double actualValue = sequence.get(sequence.size() - 1);
        double predictedValue = prediction.getDouble(0);
        double error = Math.abs(actualValue - predictedValue);
        
        (*@// Порог аномалии: 2 стандартных отклонения@*)
        double threshold = calculateStdDev(sequence) * 2;
        boolean isAnomaly = error > threshold;
        
        return new AnomalyResult(isAnomaly, error);
    }
    
    private INDArray prepareInput(List<Double> sequence) {
        (*@// Преобразование последовательности в INDArray@*)
        double[] array = sequence.stream()
            .mapToDouble(Double::doubleValue)
            .toArray();
        return Nd4j.create(array).reshape(1, array.length, 1);
    }
    
    private double calculateStdDev(List<Double> values) {
        (*@// Вычисление стандартного отклонения@*)
        double mean = values.stream()
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(0.0);
        
        double variance = values.stream()
            .mapToDouble(v -> Math.pow(v - mean, 2))
            .average()
            .orElse(0.0);
        
        return Math.sqrt(variance);
    }
    
    public static class AnomalyResult {
        private final boolean isAnomaly;
        private final double error;
        
        public AnomalyResult(boolean isAnomaly, double error) {
            this.isAnomaly = isAnomaly;
            this.error = error;
        }
        
        public boolean isAnomaly() { return isAnomaly; }
        public double getError() { return error; }
    }
}
\end{lstlisting}

\section{Реализация модуля диагностики}

\begin{lstlisting}[language=Java, caption={Модуль построения причинно-следственного графа}, label=lst:diagnostic_engine, escapeinside={(*@}{@*)}]
package com.autonomous.agents.agents;

import org.springframework.stereotype.Service;
import org.jgrapht.Graph;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;

import java.util.*;
import java.util.stream.Collectors;

@Service
public class DiagnosticEngineService {
    (*@// Граф причинно-следственных связей@*)
    private Graph<String, DefaultEdge> causalGraph;
    
    public DiagnosticEngineService() {
        this.causalGraph = new DefaultDirectedGraph<>(DefaultEdge.class);
    }
    
    (*@// Построение причинно-следственного графа@*)
    public void buildCausalGraph(
            Map<String, List<Double>> metrics,
            List<LogEntry> logs,
            List<Trace> traces) {
        
        (*@// Анализ метрик на наличие аномалий@*)
        for (Map.Entry<String, List<Double>> entry : metrics.entrySet()) {
            if (isAnomalous(entry.getValue())) {
                causalGraph.addVertex(entry.getKey());
            }
        }
        
        (*@// Анализ логов на наличие ошибок@*)
        for (LogEntry logEntry : logs) {
            if ("ERROR".equals(logEntry.getLevel())) {
                String service = logEntry.getService();
                causalGraph.addVertex(service);
                
                (*@// Связь с метриками@*)
                for (String metric : metrics.keySet()) {
                    if (isRelated(service, metric)) {
                        causalGraph.addEdge(metric, service);
                    }
                }
            }
        }
        
        (*@// Анализ трейсов для построения связей@*)
        for (Trace trace : traces) {
            addTraceRelations(trace);
        }
    }
    
    (*@// Поиск корневых причин@*)
    public List<String> findRootCause() {
        List<String> rootCauses = new ArrayList<>();
        
        (*@// Корневая причина - узел без входящих рёбер@*)
        for (String node : causalGraph.vertexSet()) {
            if (causalGraph.inDegreeOf(node) == 0) {
                rootCauses.add(node);
            }
        }
        
        return rootCauses;
    }
    
    (*@// Проверка на аномальность по правилу 3 сигм@*)
    private boolean isAnomalous(List<Double> values) {
        double mean = values.stream()
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(0.0);
        
        double variance = values.stream()
            .mapToDouble(v -> Math.pow(v - mean, 2))
            .average()
            .orElse(0.0);
        
        double std = Math.sqrt(variance);
        double lastValue = values.get(values.size() - 1);
        
        return Math.abs(lastValue - mean) > 2 * std;
    }
    
    (*@// Проверка связи между сервисом и метрикой@*)
    private boolean isRelated(String service, String metric) {
        (*@// Упрощённая логика проверки связи@*)
        String serviceLower = service.toLowerCase();
        String metricLower = metric.toLowerCase();
        return serviceLower.contains(metricLower) || 
               metricLower.contains(serviceLower);
    }
    
    (*@// Добавление связей из трейса@*)
    private void addTraceRelations(Trace trace) {
        List<Span> spans = trace.getSpans();
        
        (*@// Связи между последовательными спанами@*)
        for (int i = 0; i < spans.size() - 1; i++) {
            String sourceService = spans.get(i).getService();
            String targetService = spans.get(i + 1).getService();
            
            causalGraph.addVertex(sourceService);
            causalGraph.addVertex(targetService);
            causalGraph.addEdge(sourceService, targetService);
        }
    }
    
    (*@// Вспомогательные классы@*)
    public static class LogEntry {
        private String level;
        private String service;
        
        public String getLevel() { return level; }
        public String getService() { return service; }
    }
    
    public static class Trace {
        private List<Span> spans;
        public List<Span> getSpans() { return spans; }
    }
    
    public static class Span {
        private String service;
        public String getService() { return service; }
    }
}
\end{lstlisting}

\section{Реализация модуля оркестрации и исполнения}

\begin{lstlisting}[language=Java, caption={Модуль оркестрации и безопасного исполнения действий}, label=lst:orchestrator_executor, escapeinside={(*@}{@*)}]
package com.autonomous.agents.agents;

import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class OrchestratorService {

    private final SafeExecutorService safeExecutorService;

    public OrchestratorService(SafeExecutorService safeExecutorService) {
        this.safeExecutorService = safeExecutorService;
    }

    (*@// Формирование и выполнение плана восстановления@*)
    public void handleDiagnosis(DiagnosisReport report) {
        List<RecoveryAction> actions = buildRecoveryPlan(report);
        for (RecoveryAction action : actions) {
            safeExecutorService.execute(action);
        }
    }

    private List<RecoveryAction> buildRecoveryPlan(DiagnosisReport report) {
        (*@// Упрощённая логика построения плана@*)
        return List.of(
            new RecoveryAction("scale_up", report.getService(), 2),
            new RecoveryAction("restart", report.getService(), 0)
        );
    }

    public static class DiagnosisReport {
        private final String service;

        public DiagnosisReport(String service) {
            this.service = service;
        }

        public String getService() {
            return service;
        }
    }

    public static class RecoveryAction {
        private final String type;
        private final String targetService;
        private final int factor;

        public RecoveryAction(String type, String targetService, int factor) {
            this.type = type;
            this.targetService = targetService;
            this.factor = factor;
        }

        public String getType() { return type; }
        public String getTargetService() { return targetService; }
        public int getFactor() { return factor; }
    }
}

@Service
class SafeExecutorService {

    (*@// Проверка риска и безопасное выполнение действий@*)
    public void execute(OrchestratorService.RecoveryAction action) {
        if (isSafe(action)) {
            apply(action);
        } else {
            (*@// Логируем отказ по критериям безопасности@*)
        }
    }

    private boolean isSafe(OrchestratorService.RecoveryAction action) {
        (*@// Упрощённая проверка риска@*)
        return !"restart".equals(action.getType()) || action.getFactor() == 0;
    }

    private void apply(OrchestratorService.RecoveryAction action) {
        (*@// Взаимодействие с Kubernetes API для масштабирования или перезапуска@*)
    }
}
\end{lstlisting}

\section{Реализация MCP-сервера}

\begin{lstlisting}[language=Java, caption={Упрощённый MCP-сервер для обработки JSON-RPC запросов}, label=lst:mcp_server, escapeinside={(*@}{@*)}]
package com.autonomous.agents.mcp;

import org.springframework.stereotype.Service;

import java.util.Map;

@Service
public class McpServer {

    private final SystemContextTool systemContextTool;
    private final LogAnalysisTool logAnalysisTool;

    public McpServer(SystemContextTool systemContextTool,
                     LogAnalysisTool logAnalysisTool) {
        this.systemContextTool = systemContextTool;
        this.logAnalysisTool = logAnalysisTool;
    }

    (*@// Обработка JSON-RPC запроса от LLM-агента@*)
    public Map<String, Object> process(Map<String, Object> request) {
        String method = (String) request.get("method");
        Map<String, Object> params = (Map<String, Object>) request.get("params");

        switch (method) {
            case "system_context":
                return systemContextTool.invoke(params);
            case "log_analysis":
                return logAnalysisTool.invoke(params);
            default:
                throw new IllegalArgumentException("Unknown method: " + method);
        }
    }

    public interface McpTool {
        Map<String, Object> invoke(Map<String, Object> params);
    }

    @Service
    public static class SystemContextTool implements McpTool {
        @Override
        public Map<String, Object> invoke(Map<String, Object> params) {
            (*@// Возврат агрегированного контекста системы@*)
            return Map.of("metrics", Map.of(), "services", Map.of());
        }
    }

    @Service
    public static class LogAnalysisTool implements McpTool {
        @Override
        public Map<String, Object> invoke(Map<String, Object> params) {
            (*@// Возврат результатов анализа логов@*)
            return Map.of("errors", Map.of(), "patterns", Map.of());
        }
    }
}
\end{lstlisting}
