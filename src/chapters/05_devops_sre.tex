\chapter{DevOps, SRE и архитектуры обеспечения стабильности}

\section{DevOps и автоматизация доставки}

DevOps объединяет разработку и эксплуатацию в единый процесс с автоматизацией всех этапов жизненного цикла ПО \cite{kim_devops_handbook,devops_culture}. SRE (Site Reliability Engineering) применяет инженерные принципы к задачам эксплуатации, фокусируясь на надёжности, производительности и автоматизации \cite{google_sre_book,sre_principles}. Обе практики формируют инфраструктурный слой, в который встраиваются автономные агенты.

Время доставки изменений:
\begin{equation}
T_{\text{delivery}} = T_{\text{build}} + T_{\text{test}} + T_{\text{deploy}} + T_{\text{verify}}
\label{eq:delivery_time}
\end{equation}

Время восстановления после инцидента:
\begin{equation}
\text{MTTR} = T_{\text{detection}} + T_{\text{diagnosis}} + T_{\text{recovery}} + T_{\text{verification}}
\label{eq:mttr_components}
\end{equation}

Именно $T_{\text{diagnosis}}$ и $T_{\text{recovery}}$ являются целевыми компонентами для автоматизации агентами --- на них приходится 60--80\% MTTR в типичных организациях \cite{continuous_deployment}.

\section{GitOps и декларативное управление}

GitOps формализует управление инфраструктурой через декларативное описание желаемого состояния в Git \cite{weaveworks_gitops}:
\begin{equation}
\Delta S = S_{\text{desired}} - S_{\text{current}}, \quad \text{если } \Delta S \neq \emptyset \text{ то } S_{\text{current}} \leftarrow S_{\text{desired}}
\label{eq:gitops}
\end{equation}

Откат изменений через \texttt{git revert} обеспечивает гарантированное возвращение к предыдущему состоянию. Агенты восстановления используют аналогичный принцип: Safe Executor сохраняет состояние перед действием и при ухудшении метрик выполняет откат к сохранённому состоянию (формула \ref{eq:rollback_model}).

\section{Механизмы самовосстановления Kubernetes}

Kubernetes обеспечивает базовый уровень самовосстановления \cite{burns_kubernetes,kubernetes_self_healing,kubernetes_docs}, на который надстраиваются агенты.

Liveness probe проверяет работоспособность контейнера, readiness probe --- готовность принимать трафик:
\begin{equation}
\text{Liveness}(t) = \mathbf{1}[\text{probe}(t) = \text{success}]
\label{eq:liveness_probe}
\end{equation}

ReplicaSet поддерживает заданное количество реплик $N_{\text{desired}}$. Доступность системы с $N$ идентичными репликами:
\begin{equation}
A(N) = 1 - (1 - A_{\text{single}})^N
\label{eq:replica_availability}
\end{equation}

Rolling Update обновляет реплики поэтапно с условием безопасности $N_{\text{old}} + N_{\text{new}} \geq N_{\text{min}}$.

\textbf{Ограничения Kubernetes self-healing.} Встроенные механизмы реагируют только на бинарные состояния (контейнер жив/мёртв, готов/не готов). Они не могут:
\begin{itemize}
    \item диагностировать корневую причину деградации производительности;
    \item учитывать контекст (каскадный отказ, плановый деплой, утечка памяти);
    \item принимать решения на уровне бизнес-логики (переключение circuit breaker, изменение конфигурации).
\end{itemize}

Проектируемая система расширяет этот слой через Kubernetes API: агент Safe Executor использует \texttt{kubectl scale} для горизонтального масштабирования и \texttt{kubectl rollout undo} для отката деплоев (глава~8, глава~10). В отличие от встроенных механизмов, агент принимает решения на основе контекста --- причинно-следственного графа инцидента, а не отдельных проб.

\section{Стратегии развёртывания}

Выбор стратегии развёртывания влияет на риски инцидентов, которые должна обрабатывать система агентов \cite{chaos_engineering,netflix_chaos}.

\textbf{Blue-Green deployment} использует две среды. Ожидаемый ущерб ограничен тестированием:
\begin{equation}
E[\text{damage}_{\text{BG}}] = p_{\text{error}} \cdot \text{Cost}(\text{test\_failure}) \ll \text{Cost}(\text{production\_failure})
\label{eq:bg_damage}
\end{equation}

\textbf{Canary deployment} направляет долю $\alpha$ трафика на новую версию. Критерий успешности:
\begin{equation}
\text{SuccessRate}_{\text{canary}} > \text{SuccessRate}_{\text{baseline}} - \epsilon
\label{eq:canary_success}
\end{equation}

При выполнении условия $\alpha$ постепенно увеличивается до~1. В сценарии~4 прототипа (глава~10) агенты автоматически детектируют ухудшение метрик после деплоя и инициируют откат, что фактически реализует автоматический canary analysis.

\section{SRE: SLO, SLI и Error Budget}

Ключевой инструмент SRE --- Service Level Objective (SLO) \cite{google_sre_book}:
\begin{equation}
\text{SLO}_{\text{availability}} = P(\text{uptime} \geq 99.9\%) = 0.999
\label{eq:slo}
\end{equation}

Error Budget определяет допустимый объём ошибок:
\begin{equation}
\text{Error Budget} = 1 - \text{SLO}, \quad \text{Budget Used} = \frac{\text{MTTR} \cdot N_{\text{incidents}}}{T_{\text{period}}}
\label{eq:error_budget}
\end{equation}

При $\text{Budget Used} > \text{Error Budget}$ релизы замораживаются до восстановления бюджета.

Service Level Indicator (SLI) измеряет фактический уровень обслуживания:
\begin{equation}
\text{SLI} = \frac{N_{\text{good}}}{N_{\text{total}}}
\label{eq:sli}
\end{equation}

\textbf{Связь с агентами.} SLO и error budget задают внешние ограничения для Safe Executor: действия восстановления должны не только снижать MTTR конкретного инцидента, но и обеспечивать соблюдение SLO. Конкретный пример: при текущем $\text{SLI} = 99.92\%$ и $\text{SLO} = 99.9\%$ оставшийся error budget составляет $0.02\%$ --- агент переключается на консервативную стратегию, повышая порог $\theta_{\text{risk}}$ (формула \ref{eq:safety_criterion}) и допуская только действия с минимальным риском (перезапуск пода, увеличение реплик), блокируя рискованные операции (изменение конфигурации, откат деплоя).

\medskip

DevOps/SRE-практики формируют инфраструктурный контекст для автономных агентов: GitOps обеспечивает слой выполнения действий с гарантированным откатом, Kubernetes self-healing --- базовый уровень восстановления, стратегии развёртывания определяют сценарии инцидентов, а SLO/error budget задают количественные ограничения на безопасность решений.
