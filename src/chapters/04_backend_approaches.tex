\chapter{Backend-подходы к устойчивым системам}

\section{Синхронные и асинхронные архитектуры}

В распределённых системах устойчивость backend-уровня определяется способностью сохранять допустимые значения доступности, времени отклика и уровня ошибок при отказах компонентов и перегрузках. Для автономных агентов диагностики и восстановления критически важно понимание архитектурных паттернов, поскольку алгоритмы восстановления опираются на них при выборе действий.

В синхронной архитектуре общая задержка цепочки из $n$ вызовов растёт линейно:
\begin{equation}
T_{\text{sync}} = \sum_{i=1}^{n} (T_{\text{request},i} + T_{\text{network},i} + T_{\text{process},i} + T_{\text{response},i})
\label{eq:sync_total_time}
\end{equation}

Асинхронная архитектура через очереди сообщений \cite{kleppmann_designing_data} устраняет блокировки. Для очереди M/M/1 с интенсивностью поступления $\lambda$ и обслуживания $\mu$ условие стабильности и среднее время пребывания в системе составляют:
\begin{equation}
\rho = \frac{\lambda}{\mu} < 1, \quad T_{\text{system}} = \frac{1}{\mu - \lambda}
\label{eq:queue_stability}
\end{equation}

Эти характеристики используются агентами при оценке пропускной способности каналов между сервисами: если $\rho \to 1$, система приближается к перегрузке, что является сигналом для масштабирования. Причинное упорядочение событий при диагностике опирается на принцип векторных часов $VC_i = [t_1, \ldots, t_n]$: $e_1 \to e_2 \Leftrightarrow VC(e_1) < VC(e_2)$ \cite{lamport_distributed_systems}, что формализует построение причинно-следственных графов (глава~8).

\section{CQRS и event-driven взаимодействие}

Разделение моделей записи и чтения (CQRS) устраняет конфликты при высокой нагрузке \cite{cqrs_pattern,event_sourcing}:
\begin{equation}
M_{\text{write}} \neq M_{\text{read}}, \quad M_{\text{read}}(t+\Delta t) = \text{Apply}(M_{\text{read}}(t), E(t, t+\Delta t))
\label{eq:cqrs_sync}
\end{equation}

Задержка синхронизации $\Delta t_{\text{sync}} = t_{\text{read}} - t_{\text{write}}$ определяет окно eventual consistency. В прототипе (глава~10) CQRS-паттерн реализуется через Kafka: агенты записывают диагнозы в один топик, а модуль визуализации читает из другого с допустимой задержкой $\Delta t_{\text{sync}} < 5$ с.

\section{Идемпотентность операций восстановления}

В распределённых системах операции могут выполняться повторно из-за сетевых ошибок \cite{kleppmann_designing_data}. Операция $f$ идемпотентна, если
\begin{equation}
\text{State}(f(f(x))) = \text{State}(f(x)) \quad \forall x \in X
\label{eq:idempotency}
\end{equation}

Для агентов восстановления идемпотентность критична: повторное применение действия (например, \texttt{kubectl scale --replicas=5}) не должно приводить к побочным эффектам, если действие уже выполнено. В Safe Executor (глава~8) все действия восстановления проектируются идемпотентными, что позволяет безопасно повторять их при сбоях коммуникации.

\section{Паттерны устойчивости к каскадным отказам}

Каскадные отказы --- основной класс инцидентов, которые должна обрабатывать проектируемая система \cite{circuit_breaker_pattern,retry_pattern}. Рассмотрим ключевые паттерны, ограничивающие распространение отказов.

\textbf{Circuit Breaker} реализует конечный автомат с состояниями $\text{State} \in \{\text{CLOSED}, \text{OPEN}, \text{HALF\_OPEN}\}$. Переход в OPEN происходит при $k \geq \theta_{\text{failure}}$ последовательных ошибок. Время ожидания перед переходом в HALF\_OPEN:
\begin{equation}
T_{\text{OPEN}} = T_{\text{base}} \cdot 2^{\text{failure\_count}}
\label{eq:circuit_breaker_timeout}
\end{equation}

\textbf{Retry с экспоненциальной задержкой} определяет время перед $i$-й попыткой:
\begin{equation}
T_{\text{delay},i} = T_{\text{base}} \cdot 2^{i-1} + \text{random}(0, T_{\text{jitter}})
\label{eq:exponential_backoff}
\end{equation}

Вероятность успеха после $n$ попыток: $P(\text{success}|n) = 1 - (1 - p)^n$, где $p$ --- вероятность успеха одной попытки.

\textbf{Bulkhead} обеспечивает изоляцию ресурсов через разделение на пулы:
\begin{equation}
R = \bigcup_{i=1}^{k} R_i, \quad R_i \cap R_j = \emptyset, \quad \text{Overload}(R_i) \not\Rightarrow \text{Overload}(R_j)
\label{eq:bulkhead}
\end{equation}

\textbf{Использование агентами.} Diagnostic Engine (глава~8) распознаёт состояние circuit breaker через анализ метрик ошибок и задержек: резкий рост $T_{\text{response}}$ с последующим падением до нуля указывает на переход в OPEN. Safe Executor при восстановлении каскадного отказа применяет паттерны в определённом порядке: (1)~активирует circuit breaker на проблемном сервисе, (2)~масштабирует зависимые сервисы, (3)~постепенно открывает circuit breaker (HALF\_OPEN) с мониторингом метрик. Это реализовано в сценарии~2 прототипа (глава~10).

\medskip

Рассмотренные паттерны формируют эксплуатационные ограничения, в рамках которых действуют автономные агенты: алгоритмы диагностики и восстановления опираются на свойства протоколов, характеристики репликации и механизмы устойчивости при выборе безопасных действий.
