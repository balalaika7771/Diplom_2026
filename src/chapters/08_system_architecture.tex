\chapter{Архитектура проектируемой системы}

\section{Постановка задачи проектирования}

Системы мониторинга, диагностики и восстановления часто реализуются как слабо связанные подсистемы, что приводит к задержкам между обнаружением инцидента и выполнением действий восстановления. Проектируемая система автоматизирует замкнутый контур <<обнаружение--диагностика--решение--восстановление>>.

Формально задача: минимизировать время восстановления
\begin{equation}
\text{MTTR} = T_{\text{detection}} + T_{\text{diagnosis}} + T_{\text{recovery}} \to \min
\label{eq:mttr_minimization}
\end{equation}
при ограничениях:
\begin{align}
P(\text{detection}) &> \theta_{\text{precision}}, \label{eq:precision_constraint} \\
P(\text{false\_positive}) &< \theta_{\text{fpr}}, \label{eq:fpr_constraint} \\
P(\text{safe\_recovery}) &> \theta_{\text{safety}}. \label{eq:safety_constraint}
\end{align}

Требования к архитектуре: модульность (независимость и заменяемость компонентов), расширяемость, безопасность действий восстановления, обработка данных в реальном времени, отказоустойчивость.

\section{Модули системы}

Архитектура включает шесть модулей, организованных в конвейер обработки инцидентов.

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=0.8cm, auto, scale=0.7, transform shape, font=\small]
    \node[rectangle, draw, fill=blue!20, minimum width=1cm, minimum height=0.6cm] (collector) {Collector};
    \node[rectangle, draw, fill=green!20, right=of collector, minimum width=1cm, minimum height=0.6cm] (analyzer) {Analyzer};
    \node[rectangle, draw, fill=yellow!20, right=of analyzer, minimum width=1cm, minimum height=0.6cm] (diagnostic) {Diagnostic};
    \node[rectangle, draw, fill=purple!20, above=of diagnostic, minimum width=1cm, minimum height=0.6cm] (llm_agent) {LLM};
    \node[rectangle, draw, fill=red!20, below=of analyzer, minimum width=1cm, minimum height=0.6cm] (orchestrator) {Orchestrator};
    \node[rectangle, draw, fill=orange!20, below=of orchestrator, minimum width=1cm, minimum height=0.6cm] (executor) {Executor};

    \draw[->, shorten >=2pt, shorten <=2pt] (collector) -- (analyzer);
    \draw[->, shorten >=2pt, shorten <=2pt] (analyzer) -- (diagnostic);
    \draw[->, shorten >=2pt, shorten <=2pt] (diagnostic) -- (orchestrator);
    \draw[->, shorten >=2pt, shorten <=2pt] (collector) -- (llm_agent);
    \draw[->, shorten >=2pt, shorten <=2pt] (diagnostic) -- (llm_agent);
    \draw[->, shorten >=2pt, shorten <=2pt] (llm_agent) -- (orchestrator);
    \draw[->, shorten >=2pt, shorten <=2pt] (orchestrator) -- (executor);
    \draw[->, dashed, shorten >=2pt, shorten <=2pt] (executor) -- (collector);
\end{tikzpicture}
\caption{Архитектура системы интеллектуальных агентов}
\label{fig:system_architecture}
\end{figure}

\subsection{Data Collector}

Модуль агрегирует данные из разнородных источников (Prometheus, Elasticsearch, Jaeger) \cite{prometheus_docs,elasticsearch_docs,jaeger_docs,opentelemetry}, приводя их к единой модели:
\begin{equation}
d = (\text{timestamp}, \text{source}, \text{type}, \text{value}, \text{metadata}), \quad \text{type} \in \{\text{metric}, \text{log}, \text{trace}\}
\label{eq:unified_data_model}
\end{equation}

Нормализация выполняется для каждого источника: $D_{\text{normalized}} = \bigcup_{i=1}^{n} f_{\text{normalize},i}(D_i)$. Время сбора определяется самым медленным источником: $T_{\text{collection}} = \max_{i} T_{\text{collect},i}$.

\subsection{Anomaly Analyzer}

Модуль объединяет результаты нескольких методов обнаружения (глава~6) через ансамблевую оценку:
\begin{equation}
\text{Anomaly Score} = \sum_{i=1}^{m} w_i \cdot r_i, \quad w_i = \frac{\exp(\alpha \cdot \text{accuracy}_i)}{\sum_{j=1}^{m} \exp(\alpha \cdot \text{accuracy}_j)}
\label{eq:ensemble_anomaly}
\end{equation}
где $r_i \in [0, 1]$ --- оценка аномальности метода $i$, $\alpha$ --- параметр температуры. Решение: $\text{Anomaly} = \mathbf{1}[\text{Anomaly Score} > \theta]$.

\subsection{LLM Agent}

Модуль анализирует неструктурированные логи и генерирует рекомендации для разработчиков, используя большие языковые модели через Model Context Protocol (глава~10):
\begin{equation}
\text{Recommendations} = \text{LLM-Agent}(L, C, \text{Metrics}, \text{Traces})
\label{eq:llm_agent_recommendations}
\end{equation}

Интеграция с остальной системой:
\begin{equation}
\text{Final Action} =
  \begin{cases}
    \text{Orchestrator Decision},
      & \text{если } \text{confidence}_{\text{orch}} > \theta, \\
    \text{LLM Recommendation},
      & \text{если } \text{confidence}_{\text{llm}} > \theta \land \text{needs\_human\_review}, \\
    \text{Human Review},
      & \text{иначе}.
  \end{cases}
\label{eq:llm_integration_arch}
\end{equation}

Такая трёхуровневая схема обеспечивает эскалацию: при высокой уверенности автоматических агентов действия выполняются немедленно; при средней уверенности LLM формирует рекомендации для разработчиков; при низкой --- инцидент передаётся человеку.

\subsection{Diagnostic Engine}

Модуль строит причинно-следственный граф инцидента $G = (V, E)$, где вершины --- сервисы и события, рёбра --- причинные связи. Вероятность связи определяется тремя признаками (аналогично~(\ref{eq:causal_probability})):
\begin{equation}
P(v_i \to v_j) = \sigma\left(\sum_{k} w_k \cdot f_k(v_i, v_j)\right)
\label{eq:causal_probability_arch}
\end{equation}
\begin{itemize}
    \item Временная близость: $f_{\text{time}}(v_i, v_j) = \exp(-|t_i - t_j|/\tau)$
    \item Корреляция метрик: $f_{\text{corr}}(v_i, v_j) = |\rho(v_i, v_j)|$
    \item Зависимость в трейсе: $f_{\text{trace}}(v_i, v_j) = \mathbf{1}[\text{parent}(v_j) = v_i]$
\end{itemize}

Рёбра включаются в граф при условии $P(v_i \to v_j) > \theta$ и подтверждения причинности по критерию Грейнджера \cite{lamport_distributed_systems,lynch_distributed_algorithms}:
\begin{equation}
v_j \text{ causes } v_i \Leftrightarrow \text{var}(\epsilon_{i|v_j}) < \text{var}(\epsilon_{i|\neg v_j})
\label{eq:granger_causality_arch}
\end{equation}

Поиск корневой причины:
\begin{equation}
\text{RootCause} = \arg\min_{v \in V} \left[ \text{in-degree}(v) + \lambda \cdot (1 - P(\text{anomaly}|v)) \right]
\label{eq:root_cause}
\end{equation}

Алгоритм выбирает вершину с минимальным числом входящих рёбер (<<начальная>> точка каскада) и максимальной вероятностью аномалии.

\section{Механизм консенсуса агентов}

При наличии нескольких источников рекомендаций (Diagnostic Engine, LLM-агент, rule-based политики) необходимо согласование \cite{wooldridge_agents,multi_agent_systems,herlihy_art_multiprocessor}. Мнение агента $A_i$ о действии $a$: $o_i(a) \in [0, 1]$. Вес определяется исторической точностью:
\begin{equation}
w_i = \frac{\exp(\alpha \cdot \text{accuracy}_i)}{\sum_{j=1}^{n} \exp(\alpha \cdot \text{accuracy}_j)}
\label{eq:agent_weight}
\end{equation}

Консенсусное решение:
\begin{equation}
\text{Decision} = \arg\max_{a \in \mathcal{A}} \sum_{i=1}^{n} w_i \cdot o_i(a)
\label{eq:consensus}
\end{equation}

Для итеративного согласования используется алгоритм DeGroot:
\begin{equation}
o_i^{(t+1)}(a) = \sum_{j=1}^{n} T_{ij} \cdot o_j^{(t)}(a), \quad \lim_{t \to \infty} o_i^{(t)}(a) = \bar{o}(a)
\label{eq:degroot_consensus}
\end{equation}
где $T_{ij}$ --- элемент матрицы доверия ($\sum_j T_{ij} = 1$). Сходимость гарантирована при $\lambda_2(T) < 1$.

\textbf{Разрешение конфликтов.} При расхождении рекомендаций (например, Diagnostic Engine предлагает масштабирование, а LLM --- включение circuit breaker) оркестратор использует взвешенное голосование:
\begin{equation}
\text{Vote}(a) = \sum_{i=1}^{n} w_i \cdot \mathbf{1}[o_i(a) > \theta_{\text{support}}]
\label{eq:weighted_voting}
\end{equation}

Решение принимается, если $\text{Vote}(a^*) > \theta_{\text{consensus}} \cdot \sum_i w_i$; при отсутствии консенсуса действие передаётся на ручную обработку.

\section{Безопасное исполнение решений}

Автоматическое выполнение действий восстановления несёт риски. Вероятность успеха определяется как произведение вероятностей на каждом этапе валидации:
\begin{equation}
P(\text{success}|a, s) = \prod_{i=1}^{k} P_i(\text{success}|a, s)
\label{eq:success_probability}
\end{equation}

Функция риска и критерий безопасности:
\begin{equation}
\text{Risk}(a, s) = P(\text{failure}|a, s) \cdot \text{Cost}(\text{failure}, a, s)
\label{eq:risk_function}
\end{equation}
\begin{equation}
\text{Safe}(a, s) = \begin{cases}
\text{true} & \text{если } \text{Risk}(a, s) < \theta_{\text{risk}} \land P(\text{success}|a, s) > \theta_{\text{success}} \\
\text{false} & \text{иначе}
\end{cases}
\label{eq:safety_criterion}
\end{equation}

\textbf{Постепенное применение} (gradual rollout): действие применяется на долю $\alpha \in [0,1]$ инфраструктуры. При успешной верификации $\alpha$ увеличивается до~1; при ухудшении метрик --- инициируется откат.

\textbf{Модель отката:}
\begin{equation}
\text{Rollback}(s_t, s_{t-k}) = \arg\min_{a \in \mathcal{A}_{\text{rollback}}} \left[ \|s_t - s_{t-k}\| + \lambda \cdot \text{Cost}(a) \right]
\label{eq:rollback_model}
\end{equation}
где $s_{t-k}$ --- сохранённое состояние до применения действия.

\textbf{Ограничение каскадных изменений:}
\begin{equation}
\sum_{i=1}^{n} |\Delta m_i| \leq \Delta_{\max}
\label{eq:change_limit}
\end{equation}

Это ограничение предотвращает ситуацию, когда серия малых действий в совокупности приводит к критическому изменению состояния системы.

\textbf{Уровни безопасности} определяют режим исполнения:
\begin{equation}
\text{SafetyLevel}(a) = \begin{cases}
\text{Low} & \text{если } \text{Risk}(a) < \theta_1 \quad \text{(автоматическое)} \\
\text{Medium} & \text{если } \theta_1 \leq \text{Risk}(a) < \theta_2 \quad \text{(gradual rollout)} \\
\text{High} & \text{если } \theta_2 \leq \text{Risk}(a) < \theta_3 \quad \text{(с подтверждением)} \\
\text{Critical} & \text{если } \text{Risk}(a) \geq \theta_3 \quad \text{(только вручную)}
\end{cases}
\label{eq:safety_levels}
\end{equation}

\medskip

Архитектура задаёт формальный каркас интеграции модулей: оптимизация MTTR при ограничениях на точность и безопасность, ансамблевый анализ аномалий, причинно-следственная диагностика и многоуровневая система безопасности исполнения. В главе~10 данная архитектура реализуется в виде прототипа, а в главе~11 проходит экспериментальную проверку.
