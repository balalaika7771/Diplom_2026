name: Build and release PDF

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install TeX Live and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            texlive-latex-base \
            texlive-latex-extra \
            texlive-lang-cyrillic \
            texlive-bibtex-extra \
            texlive-fonts-extra \
            texlive-science \
            texlive-pictures \
            texlive-luatex \
            texlive-extra-utils \
            texlive-font-utils \
            biber \
            make \
            pandoc \
            python3 \
            python3-pip \
            unzip \
            libreoffice \
            lua5.3
          
          # latexpand должен быть доступен через texlive-extra-utils
          # Проверяем наличие latexpand
          if ! command -v latexpand &> /dev/null; then
            echo "latexpand не найден, будет использован альтернативный метод объединения файлов"
          fi

      - name: Generate chapter lists and build PDF
        run: |
          make

      - name: Convert PDF to DOCX via API
        env:
          CLOUDCONVERT_API_KEY: ${{ secrets.CLOUDCONVERT_API_KEY }}
        run: |
          cd build
          
          # Функция для проверки валидности DOCX файла
          check_docx_valid() {
            local docx_file="$1"
            if [ ! -f "$docx_file" ] || [ ! -s "$docx_file" ]; then
              echo "  ❌ Файл не существует или пустой"
              return 1
            fi
            
            # Проверяем размер (должен быть больше 20KB для надежности)
            local FILE_SIZE=$(stat -c%s "$docx_file" 2>/dev/null || echo "0")
            if [ "$FILE_SIZE" -lt 20000 ]; then
              echo "  ❌ Файл слишком маленький ($FILE_SIZE байт)"
              return 1
            fi
            
            # Проверяем, что это валидный ZIP архив (DOCX это ZIP)
            if ! unzip -t -q "$docx_file" 2>/dev/null; then
              echo "  ❌ Файл не является валидным ZIP архивом"
              return 1
            fi
            
            # Проверяем наличие обязательных файлов в DOCX
            if ! unzip -l "$docx_file" 2>/dev/null | grep -q "word/document.xml"; then
              echo "  ❌ Отсутствует word/document.xml"
              return 1
            fi
            
            echo "  ✓ DOCX файл валиден (размер: $FILE_SIZE байт)"
            return 0
          }
          
          if [ ! -f main.pdf ]; then
            echo "❌ PDF файл не найден"
            exit 1
          fi
          
          PDF_SIZE=$(stat -c%s main.pdf 2>/dev/null || echo "0")
          echo "PDF размер: $PDF_SIZE байт"
          
          if [ "$PDF_SIZE" -lt 10000 ]; then
            echo "⚠ PDF файл слишком маленький, пропускаем конвертацию"
            exit 0
          fi
          
          # Проверяем наличие API ключа
          if [ -z "$CLOUDCONVERT_API_KEY" ]; then
            echo "⚠ CLOUDCONVERT_API_KEY не установлен, пропускаем конвертацию в DOCX"
            echo "Для использования API конвертации установите секрет CLOUDCONVERT_API_KEY в настройках репозитория"
            exit 0
          fi
          
          echo "=== Конвертация PDF в DOCX через CloudConvert API ==="
          
          # Устанавливаем curl и jq если нужно
          if ! command -v curl &> /dev/null; then
            echo "Установка curl..."
            sudo apt-get update && sudo apt-get install -y curl
          fi
          
          if ! command -v jq &> /dev/null; then
            echo "Установка jq..."
            sudo apt-get install -y jq
          fi
          
          # Создаем job с задачами: import -> convert -> export
          echo "Создание job для конвертации PDF -> DOCX..."
          JOB_RESPONSE=$(curl -s -X POST "https://api.cloudconvert.com/v2/jobs" \
            -H "Authorization: Bearer $CLOUDCONVERT_API_KEY" \
            -H "Content-Type: application/json" \
            -d '{
              "tasks": {
                "import-1": {
                  "operation": "import/upload"
                },
                "convert-1": {
                  "operation": "convert",
                  "input": "import-1",
                  "output_format": "docx",
                  "input_format": "pdf"
                },
                "export-1": {
                  "operation": "export/url",
                  "input": "convert-1"
                }
              }
            }')
          
          JOB_ID=$(echo "$JOB_RESPONSE" | jq -r '.id // empty')
          
          if [ -z "$JOB_ID" ]; then
            echo "Ошибка: не удалось создать job"
            echo "Ответ API: $JOB_RESPONSE"
            exit 1
          fi
          
          echo "Job создан: $JOB_ID"
          
          # Получаем информацию о задаче импорта для загрузки файла
          IMPORT_TASK_ID=$(echo "$JOB_RESPONSE" | jq -r '.tasks[] | select(.name == "import-1") | .id // empty')
          
          if [ -z "$IMPORT_TASK_ID" ]; then
            echo "Ошибка: не удалось получить ID задачи импорта"
            exit 1
          fi
          
          echo "Получение URL для загрузки файла..."
          IMPORT_TASK_INFO=$(curl -s -X GET "https://api.cloudconvert.com/v2/tasks/$IMPORT_TASK_ID" \
            -H "Authorization: Bearer $CLOUDCONVERT_API_KEY")
          
          UPLOAD_URL=$(echo "$IMPORT_TASK_INFO" | jq -r '.result.form.url // empty')
          
          if [ -z "$UPLOAD_URL" ]; then
            echo "Ошибка: не удалось получить URL для загрузки"
            echo "Ответ API: $IMPORT_TASK_INFO"
            exit 1
          fi
          
          # Загружаем PDF файл
          echo "Загрузка PDF файла..."
          UPLOAD_RESPONSE=$(curl -s -X POST "$UPLOAD_URL" \
            -F "file=@main.pdf")
          
          # Ждем завершения job
          echo "Ожидание завершения конвертации..."
          MAX_WAIT=600  # 10 минут максимум
          WAIT_TIME=0
          SLEEP_INTERVAL=3
          
          while [ $WAIT_TIME -lt $MAX_WAIT ]; do
            sleep $SLEEP_INTERVAL
            WAIT_TIME=$((WAIT_TIME + SLEEP_INTERVAL))
            
            JOB_STATUS=$(curl -s -X GET "https://api.cloudconvert.com/v2/jobs/$JOB_ID" \
              -H "Authorization: Bearer $CLOUDCONVERT_API_KEY")
            
            STATUS=$(echo "$JOB_STATUS" | jq -r '.status // empty')
            echo "Статус job: $STATUS (ожидание: ${WAIT_TIME}с)"
            
            if [ "$STATUS" = "finished" ]; then
              # Получаем информацию о задаче экспорта
              EXPORT_TASK_ID=$(echo "$JOB_STATUS" | jq -r '.tasks[] | select(.name == "export-1") | .id // empty')
              
              if [ -n "$EXPORT_TASK_ID" ]; then
                EXPORT_INFO=$(curl -s -X GET "https://api.cloudconvert.com/v2/tasks/$EXPORT_TASK_ID" \
                  -H "Authorization: Bearer $CLOUDCONVERT_API_KEY")
                
                DOWNLOAD_URL=$(echo "$EXPORT_INFO" | jq -r '.result.files[0].url // empty')
                
                if [ -n "$DOWNLOAD_URL" ]; then
                  echo "Скачивание DOCX файла..."
                  curl -s -L "$DOWNLOAD_URL" -o main.docx
                  
                  if check_docx_valid main.docx; then
                    FILE_SIZE=$(stat -c%s main.docx 2>/dev/null || echo "0")
                    echo "✓ DOCX файл успешно создан через CloudConvert API (размер: $FILE_SIZE байт)"
                    exit 0
                  else
                    echo "⚠ Скачанный файл невалиден"
                    exit 1
                  fi
                else
                  echo "Ошибка: не удалось получить URL для скачивания"
                  echo "$EXPORT_INFO" | jq '.'
                  exit 1
                fi
              else
                echo "Ошибка: не удалось найти задачу экспорта"
                exit 1
              fi
              break
            elif [ "$STATUS" = "error" ]; then
              echo "Ошибка конвертации"
              echo "$JOB_STATUS" | jq '.'
              exit 1
            fi
          done
          
          if [ $WAIT_TIME -ge $MAX_WAIT ]; then
            echo "Таймаут ожидания конвертации (превышен лимит ${MAX_WAIT}с)"
            exit 1
          fi
          
          # Финальная проверка
          if ! check_docx_valid main.docx; then
            echo "❌ Ошибка: DOCX файл невалиден"
            exit 1
          fi
          
          FILE_SIZE=$(stat -c%s main.docx 2>/dev/null || echo "0")
          echo ""
          echo "✓ Word документ создан успешно и валиден (размер: $FILE_SIZE байт)"
          ls -lh main.docx

      - name: Upload PDF artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-pdf
          path: build/main.pdf

      - name: Upload Word artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-word
          path: build/main.docx
        continue-on-error: true

      - name: Create GitHub Release with PDF and Word
        uses: softprops/action-gh-release@v2
        if: github.ref == 'refs/heads/main'
        with:
          tag_name: pdf-${{ github.run_id }}-${{ github.run_number }}
          name: PDF build ${{ github.run_id }}-${{ github.run_number }}
          draft: false
          prerelease: true
          files: |
            build/main.pdf
            build/main.docx

      - name: Upload to Yandex Disk
        if: github.ref == 'refs/heads/main'
        env:
          YANDEX_DISK_TOKEN: ${{ secrets.YANDEX_DISK_TOKEN }}
        run: |
          if [ -z "$YANDEX_DISK_TOKEN" ]; then
            echo "Предупреждение: YANDEX_DISK_TOKEN не установлен, пропускаем загрузку на Яндекс.Диск"
            exit 0
          fi
          
          TOKEN="$YANDEX_DISK_TOKEN"
          
          # Функция для URL-кодирования пути
          url_encode() {
            python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1], safe=''))" "$1"
          }
          
          # Функция для создания папки (если не существует)
          ensure_folder() {
            local FOLDER_PATH="$1"
            local ENCODED_PATH=$(url_encode "$FOLDER_PATH")
            
            echo "Проверка/создание папки: $FOLDER_PATH"
            
            # Сначала проверяем, существует ли папка
            CHECK_RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_PATH" \
              -H "Authorization: OAuth $TOKEN")
            
            if echo "$CHECK_RESPONSE" | grep -q '"type":"dir"'; then
              echo "Папка уже существует"
              return 0
            fi
            
            # Пытаемся создать папку
            RESPONSE=$(curl -s -X PUT \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_PATH" \
              -H "Authorization: OAuth $TOKEN")
            
            # Проверяем результат
            if echo "$RESPONSE" | grep -q '"type":"dir"\|"created"\|"path"'; then
              echo "Папка создана успешно"
              return 0
            elif echo "$RESPONSE" | grep -q "already_exists\|DiskPathPointsToExistentDirectoryError"; then
              echo "Папка уже существует"
              return 0
            else
              echo "Предупреждение: не удалось создать папку, ответ API: $RESPONSE"
              # Продолжаем в любом случае
              return 0
            fi
          }
          
          # Функция для загрузки файла на Яндекс.Диск
          upload_file() {
            local FILE_PATH="$1"
            local DISK_PATH="$2"
            local FILENAME=$(basename "$FILE_PATH")
            
            echo "Загрузка $FILENAME на Яндекс.Диск в $DISK_PATH..."
            
            # URL-кодируем путь правильно
            ENCODED_PATH=$(url_encode "$DISK_PATH")
            
            # Получаем URL для загрузки
            RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources/upload?path=$ENCODED_PATH&overwrite=true" \
              -H "Authorization: OAuth $TOKEN")
            
            UPLOAD_URL=$(echo "$RESPONSE" | grep -o '"href":"[^"]*' | cut -d'"' -f4)
            
            if [ -z "$UPLOAD_URL" ]; then
              echo "Ошибка: не удалось получить URL для загрузки"
              echo "Ответ API: $RESPONSE"
              return 1
            fi
            
            # Загружаем файл
            HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X PUT "$UPLOAD_URL" \
              --upload-file "$FILE_PATH")
            
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo "✓ Файл $FILENAME успешно загружен"
              return 0
            else
              echo "Ошибка загрузки $FILENAME: HTTP $HTTP_CODE"
              return 1
            fi
          }
          
          # Используем путь к папке "Диссертация"
          BASE_PATH="disk:/Диссертация"
          
          # Проверяем существование папки и создаем если нужно
          echo "Проверка/создание папки: $BASE_PATH"
          ENCODED_BASE=$(url_encode "$BASE_PATH")
          RESPONSE=$(curl -s -X GET \
            "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_BASE" \
            -H "Authorization: OAuth $TOKEN")
          
          if ! echo "$RESPONSE" | grep -q '"type":"dir"'; then
            echo "Папка не существует, создаем..."
            ensure_folder "$BASE_PATH"
          else
            echo "Папка существует"
          fi
          
          # Создаем подпапку с датой и временем для каждой сборки
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          # Убираем завершающий слеш из BASE_PATH если есть
          BASE_PATH_CLEAN="${BASE_PATH%/}"
          BUILD_FOLDER="${BASE_PATH_CLEAN}/build_${TIMESTAMP}"
          
          echo "Создание подпапки для сборки: $BUILD_FOLDER"
          # Создаем подпапку для сборки
          ensure_folder "$BUILD_FOLDER"
          
          # Загружаем PDF (мы находимся в корне репозитория)
          upload_file "build/main.pdf" "${BUILD_FOLDER}/main.pdf"
          
          # Загружаем Word (если создан)
          if [ -f "build/main.docx" ]; then
            upload_file "build/main.docx" "${BUILD_FOLDER}/main.docx"
          fi
          
          echo "Все файлы загружены в: $BUILD_FOLDER"
          echo "Просмотр: https://disk.yandex.ru/d/RRdCy4WNyrE3xA"


