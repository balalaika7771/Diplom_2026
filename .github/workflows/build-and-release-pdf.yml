name: Build and release PDF

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install TeX Live and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            texlive-latex-base \
            texlive-latex-extra \
            texlive-lang-cyrillic \
            texlive-bibtex-extra \
            texlive-fonts-extra \
            texlive-science \
            texlive-pictures \
            texlive-luatex \
            texlive-extra-utils \
            texlive-font-utils \
            biber \
            make \
            pandoc \
            python3 \
            python3-pip \
            unzip \
            libreoffice \
            lua5.3
          
          # latexpand должен быть доступен через texlive-extra-utils
          # Проверяем наличие latexpand
          if ! command -v latexpand &> /dev/null; then
            echo "latexpand не найден, будет использован альтернативный метод объединения файлов"
          fi

      - name: Generate chapter lists and build PDF
        run: |
          make

      - name: Convert LaTeX to Word document
        run: |
          cd build
          
          # Метод 1: Используем latexpand для объединения всех включений в один файл
          echo "Объединение LaTeX файлов..."
          if command -v latexpand &> /dev/null; then
            echo "Используем latexpand для объединения файлов..."
            # Пробуем с библиографией
            if [ -f main.bbl ]; then
              latexpand --expand-bbl main.bbl main.tex > main_expanded.tex 2>&1
              if [ $? -ne 0 ] || [ ! -s main_expanded.tex ]; then
                echo "latexpand с библиографией не сработал, пробуем без..."
                latexpand main.tex > main_expanded.tex 2>&1
              fi
            else
              latexpand main.tex > main_expanded.tex 2>&1
            fi
            
            # Проверяем результат
            if [ ! -s main_expanded.tex ]; then
              echo "latexpand не создал файл, используем исходный main.tex"
              cp main.tex main_expanded.tex
            else
              echo "✓ Файлы объединены через latexpand ($(wc -l < main_expanded.tex) строк)"
            fi
          else
            echo "latexpand не найден, используем исходный main.tex"
            cp main.tex main_expanded.tex
          fi
          
          # Метод 2: Конвертируем через pandoc с расширенным файлом
          echo "Конвертация в DOCX через pandoc..."
          PANDOC_SUCCESS=false
          
          # Попытка 1: с максимальными опциями
          pandoc main_expanded.tex \
            --from=latex+raw_tex+tex_math_dollars \
            --to=docx \
            --output=main.docx \
            --standalone \
            --wrap=none \
            --extract-media=media \
            --toc \
            --toc-depth=3 \
            2>&1 | tee pandoc.log
          
          if [ -f main.docx ] && [ -s main.docx ]; then
            FILE_SIZE=$(stat -f%z main.docx 2>/dev/null || stat -c%s main.docx 2>/dev/null || echo "0")
            if [ "$FILE_SIZE" -gt 10000 ]; then
              echo "✓ Pandoc успешно создал DOCX (размер: $FILE_SIZE байт)"
              PANDOC_SUCCESS=true
            else
              echo "⚠ DOCX файл слишком маленький ($FILE_SIZE байт), пробуем другой метод..."
              rm -f main.docx
            fi
          fi
          
          # Попытка 2: упрощенный вариант
          if [ "$PANDOC_SUCCESS" = false ]; then
            echo "Попытка упрощенной конвертации через pandoc..."
            pandoc main_expanded.tex \
              --from=latex \
              --to=docx \
              --output=main.docx \
              --standalone \
              2>&1 | tee -a pandoc.log
            
            if [ -f main.docx ] && [ -s main.docx ]; then
              FILE_SIZE=$(stat -f%z main.docx 2>/dev/null || stat -c%s main.docx 2>/dev/null || echo "0")
              if [ "$FILE_SIZE" -gt 10000 ]; then
                echo "✓ Pandoc создал DOCX упрощенным методом (размер: $FILE_SIZE байт)"
                PANDOC_SUCCESS=true
              fi
            fi
          fi
          
          # Метод 3: Если pandoc не сработал, пробуем через PDF -> DOCX через LibreOffice
          if [ "$PANDOC_SUCCESS" = false ]; then
            echo "Pandoc не сработал, пробуем конвертацию PDF -> DOCX через LibreOffice..."
            if [ -f main.pdf ]; then
              echo "Конвертация PDF в DOCX..."
              libreoffice --headless --convert-to docx --outdir . main.pdf 2>&1
              
              if [ -f main.docx ]; then
                FILE_SIZE=$(stat -f%z main.docx 2>/dev/null || stat -c%s main.docx 2>/dev/null || echo "0")
                if [ "$FILE_SIZE" -gt 10000 ]; then
                  echo "✓ PDF успешно конвертирован в DOCX (размер: $FILE_SIZE байт)"
                  PANDOC_SUCCESS=true
                fi
              fi
            fi
          fi
          
          # Метод 4: Через htlatex -> ODT -> DOCX
          if [ "$PANDOC_SUCCESS" = false ]; then
            echo "Попытка конвертации через htlatex -> ODT -> DOCX..."
            htlatex main_expanded.tex "odt" "" "" "-interaction=nonstopmode" 2>&1 | tail -20
            
            if [ -f main_expanded.odt ]; then
              echo "Конвертация ODT в DOCX через LibreOffice..."
              libreoffice --headless --convert-to docx --outdir . main_expanded.odt 2>&1
              
              if [ -f main_expanded.docx ]; then
                mv main_expanded.docx main.docx
                FILE_SIZE=$(stat -f%z main.docx 2>/dev/null || stat -c%s main.docx 2>/dev/null || echo "0")
                if [ "$FILE_SIZE" -gt 10000 ]; then
                  echo "✓ ODT успешно конвертирован в DOCX (размер: $FILE_SIZE байт)"
                  PANDOC_SUCCESS=true
                fi
              fi
            fi
          fi
          
          # Проверяем финальный результат
          if [ ! -f main.docx ] || [ ! -s main.docx ]; then
            echo "❌ Ошибка: Word документ не создан или пустой"
            echo "Размер файла: $(ls -lh main.docx 2>/dev/null || echo 'файл не существует')"
            echo "Последние строки лога pandoc:"
            tail -30 pandoc.log 2>/dev/null || echo "Лог не найден"
            exit 1
          fi
          
          FILE_SIZE=$(stat -f%z main.docx 2>/dev/null || stat -c%s main.docx 2>/dev/null || echo "0")
          if [ "$FILE_SIZE" -lt 10000 ]; then
            echo "⚠ Предупреждение: DOCX файл очень маленький ($FILE_SIZE байт), возможно пустой"
            echo "Последние строки лога pandoc:"
            tail -30 pandoc.log 2>/dev/null || echo "Лог не найден"
          else
            echo "✓ Word документ создан успешно (размер: $FILE_SIZE байт)"
          fi
          ls -lh main.docx

      - name: Upload PDF artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-pdf
          path: build/main.pdf

      - name: Upload Word artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-word
          path: build/main.docx
        continue-on-error: true

      - name: Create GitHub Release with PDF and Word
        uses: softprops/action-gh-release@v2
        if: github.ref == 'refs/heads/main'
        with:
          tag_name: pdf-${{ github.run_id }}-${{ github.run_number }}
          name: PDF build ${{ github.run_id }}-${{ github.run_number }}
          draft: false
          prerelease: true
          files: |
            build/main.pdf
            build/main.docx

      - name: Upload to Yandex Disk
        if: github.ref == 'refs/heads/main'
        env:
          YANDEX_DISK_TOKEN: ${{ secrets.YANDEX_DISK_TOKEN }}
        run: |
          if [ -z "$YANDEX_DISK_TOKEN" ]; then
            echo "Предупреждение: YANDEX_DISK_TOKEN не установлен, пропускаем загрузку на Яндекс.Диск"
            exit 0
          fi
          
          TOKEN="$YANDEX_DISK_TOKEN"
          
          # Функция для URL-кодирования пути
          url_encode() {
            python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1], safe=''))" "$1"
          }
          
          # Функция для создания папки (если не существует)
          ensure_folder() {
            local FOLDER_PATH="$1"
            local ENCODED_PATH=$(url_encode "$FOLDER_PATH")
            
            echo "Проверка/создание папки: $FOLDER_PATH"
            
            # Сначала проверяем, существует ли папка
            CHECK_RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_PATH" \
              -H "Authorization: OAuth $TOKEN")
            
            if echo "$CHECK_RESPONSE" | grep -q '"type":"dir"'; then
              echo "Папка уже существует"
              return 0
            fi
            
            # Пытаемся создать папку
            RESPONSE=$(curl -s -X PUT \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_PATH" \
              -H "Authorization: OAuth $TOKEN")
            
            # Проверяем результат
            if echo "$RESPONSE" | grep -q '"type":"dir"\|"created"\|"path"'; then
              echo "Папка создана успешно"
              return 0
            elif echo "$RESPONSE" | grep -q "already_exists\|DiskPathPointsToExistentDirectoryError"; then
              echo "Папка уже существует"
              return 0
            else
              echo "Предупреждение: не удалось создать папку, ответ API: $RESPONSE"
              # Продолжаем в любом случае
              return 0
            fi
          }
          
          # Функция для загрузки файла на Яндекс.Диск
          upload_file() {
            local FILE_PATH="$1"
            local DISK_PATH="$2"
            local FILENAME=$(basename "$FILE_PATH")
            
            echo "Загрузка $FILENAME на Яндекс.Диск в $DISK_PATH..."
            
            # URL-кодируем путь правильно
            ENCODED_PATH=$(url_encode "$DISK_PATH")
            
            # Получаем URL для загрузки
            RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources/upload?path=$ENCODED_PATH&overwrite=true" \
              -H "Authorization: OAuth $TOKEN")
            
            UPLOAD_URL=$(echo "$RESPONSE" | grep -o '"href":"[^"]*' | cut -d'"' -f4)
            
            if [ -z "$UPLOAD_URL" ]; then
              echo "Ошибка: не удалось получить URL для загрузки"
              echo "Ответ API: $RESPONSE"
              return 1
            fi
            
            # Загружаем файл
            HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X PUT "$UPLOAD_URL" \
              --upload-file "$FILE_PATH")
            
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo "✓ Файл $FILENAME успешно загружен"
              return 0
            else
              echo "Ошибка загрузки $FILENAME: HTTP $HTTP_CODE"
              return 1
            fi
          }
          
          # Используем путь к папке "Диссертация"
          BASE_PATH="disk:/Диссертация"
          
          # Проверяем существование папки и создаем если нужно
          echo "Проверка/создание папки: $BASE_PATH"
          ENCODED_BASE=$(url_encode "$BASE_PATH")
          RESPONSE=$(curl -s -X GET \
            "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_BASE" \
            -H "Authorization: OAuth $TOKEN")
          
          if ! echo "$RESPONSE" | grep -q '"type":"dir"'; then
            echo "Папка не существует, создаем..."
            ensure_folder "$BASE_PATH"
          else
            echo "Папка существует"
          fi
          
          # Создаем подпапку с датой и временем для каждой сборки
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          # Убираем завершающий слеш из BASE_PATH если есть
          BASE_PATH_CLEAN="${BASE_PATH%/}"
          BUILD_FOLDER="${BASE_PATH_CLEAN}/build_${TIMESTAMP}"
          
          echo "Создание подпапки для сборки: $BUILD_FOLDER"
          # Создаем подпапку для сборки
          ensure_folder "$BUILD_FOLDER"
          
          # Загружаем PDF (мы находимся в корне репозитория)
          upload_file "build/main.pdf" "${BUILD_FOLDER}/main.pdf"
          
          # Загружаем Word (если создан)
          if [ -f "build/main.docx" ]; then
            upload_file "build/main.docx" "${BUILD_FOLDER}/main.docx"
          fi
          
          echo "Все файлы загружены в: $BUILD_FOLDER"
          echo "Просмотр: https://disk.yandex.ru/d/RRdCy4WNyrE3xA"


