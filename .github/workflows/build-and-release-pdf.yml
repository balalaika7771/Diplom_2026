name: Build and release PDF

on:
  push:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install TeX Live and dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            texlive-latex-base \
            texlive-latex-extra \
            texlive-lang-cyrillic \
            texlive-bibtex-extra \
            texlive-fonts-extra \
            texlive-science \
            texlive-pictures \
            texlive-luatex \
            texlive-extra-utils \
            texlive-font-utils \
            texlive-htmlxml \
            biber \
            make \
            pandoc \
            python3 \
            python3-pip \
            unzip \
            libreoffice \
            lua5.3
          
          # Устанавливаем latexpand и make4ht для объединения и конвертации LaTeX файлов
          pip3 install latexpand make4ht

      - name: Generate chapter lists and build PDF
        run: |
          make

      - name: Convert LaTeX to Word document
        run: |
          cd build
          
          # Метод 1: Используем latexpand для объединения всех включений в один файл
          echo "Объединение LaTeX файлов через latexpand..."
          latexpand --expand-bbl main.bbl main.tex > main_expanded.tex 2>/dev/null || \
          latexpand main.tex > main_expanded.tex 2>/dev/null || \
          cp main.tex main_expanded.tex
          
          # Метод 2: Конвертируем через pandoc с расширенным файлом
          echo "Конвертация в DOCX через pandoc..."
          pandoc main_expanded.tex \
            --from=latex \
            --to=docx \
            --output=main.docx \
            --standalone \
            --wrap=none \
            --extract-media=media \
            --reference-doc=/usr/share/pandoc/data/reference.docx 2>/dev/null || \
          pandoc main_expanded.tex \
            --from=latex \
            --to=docx \
            --output=main.docx \
            --standalone || \
          echo "Warning: pandoc conversion completed with warnings"
          
          # Метод 3: Если pandoc не сработал, пробуем через make4ht -> ODT -> DOCX
          if [ ! -f main.docx ] || [ ! -s main.docx ]; then
            echo "Попытка конвертации через make4ht..."
            # Конвертируем через make4ht в ODT
            make4ht -f odt main_expanded.tex 2>/dev/null || \
            echo "make4ht conversion attempted"
            
            # Если получили ODT, конвертируем в DOCX через LibreOffice
            if [ -f main_expanded.odt ]; then
              echo "Конвертация ODT в DOCX через LibreOffice..."
              libreoffice --headless --convert-to docx --outdir . main_expanded.odt 2>/dev/null || \
              echo "LibreOffice conversion attempted"
              
              if [ -f main_expanded.docx ]; then
                mv main_expanded.docx main.docx
              fi
            fi
          fi
          
          # Метод 4: Последняя попытка - напрямую через htlatex
          if [ ! -f main.docx ] || [ ! -s main.docx ]; then
            echo "Последняя попытка через htlatex..."
            htlatex main_expanded.tex "odt" "" "" "-interaction=nonstopmode" 2>/dev/null || \
            echo "htlatex conversion attempted"
            
            if [ -f main_expanded.odt ]; then
              libreoffice --headless --convert-to docx --outdir . main_expanded.odt 2>/dev/null
              if [ -f main_expanded.docx ]; then
                mv main_expanded.docx main.docx
              fi
            fi
          fi
          
          # Проверяем, что файл создан и не пустой
          if [ ! -f main.docx ] || [ ! -s main.docx ]; then
            echo "Error: Word document was not created or is empty"
            echo "Размер файла: $(ls -lh main.docx 2>/dev/null || echo 'файл не существует')"
            exit 1
          fi
          
          echo "✓ Word документ создан успешно"
          ls -lh main.docx

      - name: Upload PDF artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-pdf
          path: build/main.pdf

      - name: Upload Word artifact
        uses: actions/upload-artifact@v4
        with:
          name: dissertation-word
          path: build/main.docx
        continue-on-error: true

      - name: Create GitHub Release with PDF and Word
        uses: softprops/action-gh-release@v2
        if: github.ref == 'refs/heads/main'
        with:
          tag_name: pdf-${{ github.run_id }}-${{ github.run_number }}
          name: PDF build ${{ github.run_id }}-${{ github.run_number }} (${{ github.event.head_commit.timestamp || github.run_id }})
          draft: false
          prerelease: true
          files: |
            build/main.pdf
            build/main.docx

      - name: Upload to Yandex Disk
        if: github.ref == 'refs/heads/main'
        env:
          YANDEX_DISK_TOKEN: ${{ secrets.YANDEX_DISK_TOKEN }}
        run: |
          if [ -z "$YANDEX_DISK_TOKEN" ]; then
            echo "Предупреждение: YANDEX_DISK_TOKEN не установлен, пропускаем загрузку на Яндекс.Диск"
            exit 0
          fi
          
          TOKEN="$YANDEX_DISK_TOKEN"
          
          # Функция для URL-кодирования пути
          url_encode() {
            python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.argv[1], safe=''))" "$1"
          }
          
          # Функция для создания папки (если не существует)
          ensure_folder() {
            local FOLDER_PATH="$1"
            local ENCODED_PATH=$(url_encode "$FOLDER_PATH")
            
            echo "Проверка/создание папки: $FOLDER_PATH"
            RESPONSE=$(curl -s -X PUT \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_PATH" \
              -H "Authorization: OAuth $TOKEN")
            
            # Проверяем результат
            if echo "$RESPONSE" | grep -q "already_exists\|DiskPathPointsToExistentDirectoryError\|created"; then
              echo "Папка готова к использованию"
              return 0
            else
              echo "Ответ API при создании папки: $RESPONSE"
              # Продолжаем в любом случае, возможно папка уже существует
              return 0
            fi
          }
          
          # Функция для загрузки файла на Яндекс.Диск
          upload_file() {
            local FILE_PATH="$1"
            local DISK_PATH="$2"
            local FILENAME=$(basename "$FILE_PATH")
            
            echo "Загрузка $FILENAME на Яндекс.Диск в $DISK_PATH..."
            
            # URL-кодируем путь правильно
            ENCODED_PATH=$(url_encode "$DISK_PATH")
            
            # Получаем URL для загрузки
            RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources/upload?path=$ENCODED_PATH&overwrite=true" \
              -H "Authorization: OAuth $TOKEN")
            
            UPLOAD_URL=$(echo "$RESPONSE" | grep -o '"href":"[^"]*' | cut -d'"' -f4)
            
            if [ -z "$UPLOAD_URL" ]; then
              echo "Ошибка: не удалось получить URL для загрузки"
              echo "Ответ API: $RESPONSE"
              return 1
            fi
            
            # Загружаем файл
            HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X PUT "$UPLOAD_URL" \
              --upload-file "$FILE_PATH")
            
            if [ "$HTTP_CODE" = "201" ] || [ "$HTTP_CODE" = "202" ]; then
              echo "✓ Файл $FILENAME успешно загружен"
              return 0
            else
              echo "Ошибка загрузки $FILENAME: HTTP $HTTP_CODE"
              return 1
            fi
          }
          
          # Пробуем найти правильный путь к расшаренной папке
          # Сначала пробуем стандартные варианты
          POSSIBLE_PATHS=("disk:/Диссертация" "disk:/Диссертация/" "disk:/")
          
          BASE_PATH=""
          for TEST_PATH in "${POSSIBLE_PATHS[@]}"; do
            echo "Проверка пути: $TEST_PATH"
            ENCODED_TEST=$(url_encode "$TEST_PATH")
            RESPONSE=$(curl -s -X GET \
              "https://cloud-api.yandex.net/v1/disk/resources?path=$ENCODED_TEST" \
              -H "Authorization: OAuth $TOKEN")
            
            if echo "$RESPONSE" | grep -q '"type":"dir"\|"path":'; then
              BASE_PATH="$TEST_PATH"
              echo "Найден рабочий путь: $BASE_PATH"
              break
            fi
          done
          
          # Если не нашли, используем путь по умолчанию и создаем папку
          if [ -z "$BASE_PATH" ]; then
            BASE_PATH="disk:/Диссертация"
            echo "Используем путь по умолчанию: $BASE_PATH"
            ensure_folder "$BASE_PATH"
          fi
          
          # Создаем подпапку с датой и временем для каждой сборки
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          BUILD_FOLDER="${BASE_PATH}/build_${TIMESTAMP}"
          
          # Создаем подпапку для сборки
          ensure_folder "$BUILD_FOLDER"
          
          # Загружаем PDF
          upload_file "build/main.pdf" "${BUILD_FOLDER}/main.pdf"
          
          # Загружаем Word (если создан)
          if [ -f "build/main.docx" ]; then
            upload_file "build/main.docx" "${BUILD_FOLDER}/main.docx"
          fi
          
          echo "Все файлы загружены в: $BUILD_FOLDER"
          echo "Просмотр: https://disk.yandex.ru/d/RRdCy4WNyrE3xA"


